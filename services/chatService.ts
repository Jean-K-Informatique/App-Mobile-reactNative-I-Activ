import { collection, query, where, getDocs, QueryDocumentSnapshot, DocumentData } from 'firebase/firestore';
import { auth, db } from './firebaseConfig';

export interface Chat {
  id: string;
  name: string;
  description?: string;
  welcomeMessage?: string;
  model?: string;
  provider?: string;
  allowedUsers: string[];
  [key: string]: any; // pour les autres champs possibles
}

/**
 * R√©cup√®re les chats accessibles √† l'utilisateur connect√©
 * @returns Promise<Chat[]> - Liste des chats o√π l'utilisateur est autoris√©
 */
export async function fetchUserChats(): Promise<Chat[]> {
  const user = auth.currentUser;
  if (!user) {
    console.warn("Aucun utilisateur connect√©.");
    return [];
  }
  
  try {
    const uid = user.uid;
    console.log('üîç R√©cup√©ration des chats pour l\'utilisateur:', uid);
    
    // R√©f√©rence √† la collection "chats"
    const chatsRef = collection(db, 'chats');
    
    // Requ√™te filtrant les chats o√π allowedUsers contient l'UID
    const q = query(chatsRef, where('allowedUsers', 'array-contains', uid));
    
    const querySnapshot = await getDocs(q);
    
    // Extraire les donn√©es des documents
    const chatList: Chat[] = querySnapshot.docs.map((doc: QueryDocumentSnapshot<DocumentData>) => {
      const data = doc.data();
      return {
        id: doc.id,
        ...data
      } as Chat;
    });
    
    console.log(`‚úÖ ${chatList.length} chats trouv√©s`);
    
    // Log simplifi√© pour chaque chat
    chatList.forEach((chat, index) => {
      console.log(`üìã Chat ${index + 1}: "${chat.name}" (${chat.model || 'mod√®le non sp√©cifi√©'})`);
    });
    
    return chatList;
  } catch (error) {
    console.error("‚ùå Erreur lors de la r√©cup√©ration des chats :", error);
    return [];
  }
}

// Hook supprim√© pour √©viter les boucles infinies
// Utilisez fetchUserChats() directement dans les composants 